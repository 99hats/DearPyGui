<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
    <meta name="generator" content="pdoc 0.8.4" />
    <title>dearpygui.dearpygui API documentation</title>
    <meta name="description" content="" />
    <link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
    <link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
    <link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/styles/github.min.css" crossorigin>
    <style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.h2[id^="header-"]{margin-top:2em}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}dt:target .name{background:var(--highlight-color)}.name >.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
    <style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
    <script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
    <style>
        .inline-code {font-family: 'Monaco', 'Menlo', courier, monospace; font-size:1em; color:#fff; background:#303030; padding:0.2em}
        article a {font-weight: bold;}
        h1 {font-weight:370}
        h2 {color: #058; font-weight:370}
    </style>
    <link href="code_style.css" rel="stylesheet" type="text/css">
    <script src="rainbow-custom.min.js"></script>
</head>

<body>
<header>
    <h1><a href="index.html">DearPyGui</a></h1>
</header>
<hr>
<main id="content">
    <article><a href="#contents"></a>
        <h2>DearPyGui Tutorials</h2>
        <hr>
        <ul>
            <li><a href="#overview">Overview</a></li>
            <li><a href="#developer_tools">Developer Tools</a></li>
            <li><a href="#widgets_containers_windows">Widgets, Containers, and Windows</a></li>
<!--        TODO: maybe add a section on sizers and layouts here -->
            <li><a href="#callbacks">Callbacks</a></li>
            <li><a href="#runtime">Run-time Adding & Deleting Widgets</a></li>
            <li><a href="#logging">Built-in Logging</a></li>
            <li><a href="#data_storage">Widget Data Source & Cross-Widget Communication</a></li>
            <li><a href="#menu_bar">Menu Bars</a></li>
<!--        TODO: maybe add a section on file Dialogue here -->
            <li><a href="#plotting">Plotting</a></li>
            <li><a href="#drawing">Drawing</a></li>
            <li><a href="#tables">Tables</a></li>
            <li><a href="#input_polling">Input Polling</a></li>
            <li><a href="#multithreading">Multithreading & Asynchronous Functions</a></li>
            <li><a href="#themes_and_styles">Themes and Styles</a></li>
        </ul>
    </article>

    <article><a name="overview"></a>
        <h2>Overview</h2>
        <hr>
        <p>
            DearPyGui consists of an App, and widgets. The App is the main window of your program and is created at the end of the main python script
            by calling the function <code class="inline-code" data-language="python">start_dearpygui()</code>
            <br><br>
            Lets show an example by using the Built-in documentation function.
        </p>
        <pre><code data-language="python">from dearpygui.dearpygui import *

set_main_window_size(800, 800)
show_documentation()

start_dearpygui()</code> </pre>
        <p>
            It is important to remember that DearPyGui (a retained mode paradigm) was made from a wrapping of DearImGui (an immediate mode paradigm).
            Because of this DearPyGui has the responsibility of using the GPU to render the entire GUI every frame. This can be very beneficial
            for highly dynamic interfaces, plots, and even games.
        </p>
    </article>

    <article><a name="developer_tools"></a>
        <h2>Developer Tools</h2>
        <hr>
        <p>
            DearPyGui contains several very useful developer tools which we will utilize throughout the tutorial.
            <br><br>
            The <code class="inline-code" data-language="python">show_source()</code> requires an input of a python file name to read.
            For our example we will use our file name "main.py". These are shown below. You should update this with your file name.
        <pre><code data-language="python">from dearpygui.dearpygui import *

show_documentation()
show_debug()
show_about()
show_metrics()
show_source("main.py") //replace"main.py" with your python file name
show_logger()

start_dearpygui()</code> </pre>
        </p>
    </article>

    <article><a name="widgets_containers_windows"></a>
        <h2>Widgets, Containers, and Windows</h2>
        <hr>
        <p>
            Widgets can be broken down into:
            <ul>
            <li>regular widgets (ex. input and display items)</li>
            <li>container widgets (ex. windows, groups, popups, ect.)</li>
            </ul>
            <br><br>
            Widgets are added by their respective "add_***" commands
            <br><br>
            Every widget must have a unique name In the event that you would like widgets to appear on screen with the
            same name you must place a "##" trailing the displayed name so the widget name remains unique.
            The format is "displayed_name##unique_part".
            <br><br>
            Names are auto generated for widgets without name arguments in the method. (i.e.same_line(), spacing())

        </p>
        <pre><code data-language="python">from dearpygui.dearpygui import *

add_button("Apply##1")
add_button("Apply##applier")
add_same_line(spacing=10)
add_button("Apply##2")
add_spacing(count=5)
add_button("Apply##3")

start_dearpygui()</code> </pre>
        <p>
            Container widgets are used to hold normal widgets and are implemented by starting the container with is "add" function
            then completing the container with its respective "end" function.
            <br><br>
            Widgets, including container widgets, have a parent container and an order in which they are displayed.
            The "end" function is used to by the interpreter to auto fill out the parent of the widget. Thus by default widgets are added to
            the container that is wrapping them with the "add/end" and also in the order they are coded.
        </p>
        <pre><code data-language="python">from dearpygui.dearpygui import *

add_text("This is some text on the MainWindow")

add_window("window 2")
add_text("This is some text on window 2")
end_window()

add_text("More text on the MainWindow")

start_dearpygui()</code> </pre>
        <p>
            Widgets can also be added out of order by specifying their "parent" container
            and if they are to be added "before" a specific widget as in the example below.
        </p>
        <pre><code data-language="python">from dearpygui.dearpygui import *

add_text("First coded widget") #this is a display widget

add_text("This is some text on window 2", parent="window 2")

add_window("window 2") #this is a group widget
add_checkbox("Checkbox") #this is a input widget
end_window()

add_checkbox("Last coded widget", parent="MainWindow", before="First coded widget")

start_dearpygui()</code></pre>
        <p> Every input widget also has a value which can be set using the "default_value" keyword when being created
            or set at runtime by the commands <code class="inline-code" data-language="python">set_value()</code>
            <code class="inline-code" data-language="python">get_value()</code>. This is demonstrated below.</p>
        <pre><code data-language="python">from dearpygui.dearpygui import *

add_checkbox("Radio Button", default_value=False)
print("First value of the Radio Button is: ", get_value("Radio Button"))
set_value("Radio Button", True)
print("Value after setting the Radio Button is: ", get_value("Radio Button"))

start_dearpygui()</code></pre>
    </article>

    <article><a name="callbacks"></a>
        <h2>Callbacks</h2>
        <hr>
        <p>
            Each input widget has a callback which is activated when the widget is interacted with.
            <br><br>
            Callbacks are used to give functionality to widgets. Almost every widget in DearPyGui can use a callback.
            callbacks can either be assigned to widgets upon creation or after creation as shown in the code below.
            <br><br>
            Every callback function used in DearPyGui must take in a "sender" and "data".
            <br><br>
            The "sender" is used by DearPyGui to determine what Widget is running the function and let the user have
            access to the name of the widget sending the callback request.
            <br><br>
            The "data" argument is an optional python object that can be passed into the function. This is mostly useful when
            chaining widget callbacks.
        </p>
        <pre><code data-language="python">from dearpygui.dearpygui import *

add_button("Apply", callback="ApplyButtonCallback")

def ApplyButtonCallback(sender, data):
    print(sender)
    print(data)

add_button("Submit Data")
set_item_callback("Submit Data", "SubmitData")

def SubmitData(sender, data):
    data = "this is some data that was submitted and also applied"
    ApplyButtonCallback(sender, data)

start_dearpygui()</code> </pre>
        <p>
            Window type widgets have special callbacks that are triggered on events such as rendering, window resizing, window closing.
            The window specific callbacks can be applied to any window type widget by calling the commands
            <code class="inline-code" data-language="python">set_render_callback()</code>
            <code class="inline-code" data-language="python">set_resize_callback()</code>
            By default these functions will apply the callback to the "MainWindow".
            <br><br>
            Window Type apps applicable for the render and resize callbacks are listed below:
            <ul>
                <li>MainWindow</li>
                <li>Window</li>
                <li>Child</li>
                <li>Popup</li>
            </ul>
            The callback that is run on close of a window is specific to the window widget and used by assigning a
            callback to the "on_close" keyword argument.
        </p>
        <pre><code data-language="python">from dearpygui.dearpygui import *

add_window("close me", on_close="closeCallback")
add_text("close this window")
end_window()

def closeCallback(sender, data):
    print(sender + " has been closed")

start_dearpygui()</code> </pre>
    </article>

    <article><a name="runtime"></a>
        <h2>Run-time Adding & Deleting Widgets</h2>
        <hr>
        <p>
            With DearPyGui you can dynamically add and delete any widget at runtime. This can be done by using a callback method
            to call the desired widgets "add" command and specifying the parent the widget will belong to. By default the widget will be added to the
            MainWindow if there is not a parent specified.
            <br><br>
            In this example we used the "debug" developer tool to view the current state of the widgets.
            Go to the "App Item Layout" tab on the debug widget and this tab displays the state and properties of the App.
            clicking on the "MainWindow" tree item we can see the widgets currently displayed on the MainWindow.
            Try clicking the "Add/Delete" buttons on the main window and see the tree state change.
        </p>
        <pre><code data-language="python">from dearpygui.dearpygui import *

show_debug()
add_button("Add Buttons", callback="addButtons")
add_button("Delete Buttons", callback="deleteButtons")
add_window("Secondary Window")
end_window()

def addButtons(sender, data):
    add_button("New Button")
    add_button("New Button 2", parent="Secondary Window")


def deleteButtons(sender, data):
    delete_item("New Button")
    delete_item("New Button 2")


start_dearpygui()</code> </pre>
        <p>
            When deleting a window or container widgets it's children are deleted by default. Unless the keyword "children_only" is true.
        </p>
        <pre><code data-language="python">from dearpygui.dearpygui import *

show_debug()
add_button("Add Widgets", callback="addWidgets")
add_button("Delete Widgets", callback="deleteWidgets")

def addWidgets(sender, data):
    add_window("Secondary Window")
    end_window()
    add_button("New Button 2", parent="Secondary Window")
    add_button("New Button")


def deleteWidgets(sender, data):
    delete_item("Secondary Window")
    delete_item("New Button")


start_dearpygui()</code> </pre>
    </article>

    <article><a name="logging"></a>
        <h2>Built-in Logging</h2>
        <hr>
        <p>
            One of the many powerful built in developer tools is the Logger. This can be accessed through the command
            <code class="inline-code" data-language="python">show_logger()</code>. The logger has 6 log levels:
            <ol>
                <li>Trace</li>
                <li>Debug</li>
                <li>Info</li>
                <li>Warning</li>
                <li>Error</li>
                <li>Off</li>
            </ol>
        The log commands can be filtered by setting the log level.
        The logger will filter out the set level and any levels lower than that level.
        <br><br>
        "0" log level will show all the commands.
        <br><br>
        see below for an example
        </p>
        <pre><code data-language="python">from dearpygui.dearpygui import *

show_logger()
set_log_level(0)
log("trace message")
log_debug("debug message")
log_info("info message")
log_warning("warning message")
log_error("error message")

start_dearpygui()</code></pre>
    </article>

    <article><a name="data_storage"></a>
        <h2>Widget Data Storage & Cross-Widget Communication</h2>
        <hr>
        <p>
            It may become necessary for one widget to control another widgets value directly or for 2 widgets to control the same value.
            This can be achieved through the data item <code class="inline-code" data-language="python">add_data()</code>
            and <code class="inline-code" data-language="python">get_data()</code>.
            <br><br>
            When a data source is used, the widget's value and data source changes are mirrored to one another.
            This can be useful to link to any widgets to use the same data.
            An example is shown below.

        </p>
        <pre><code data-language="python">from dearpygui.dearpygui import *

add_checkbox("Radio Button1", data_source="data1")
add_checkbox("Radio Button2", data_source="data1")
add_data("data1", True)
add_button("button", callback="print_me")


def print_me(sender, data):
    print(get_value("Radio Button1"))
    print(get_value("Radio Button2"))
    print(get_data("data1"))


start_dearpygui()</code></pre>
        <p>
            Another use for data items is to store data to be accessed anywhere even in callbacks as seen below.
        </p>
        <pre><code data-language="python">from dearpygui.dearpygui import *

add_checkbox("Radio Button")
add_button("Get Value and Store", callback="store_data")
add_button("Get Data and Print", callback="print_data")


def store_data(sender, data):
    add_data("storedData", get_value("Radio Button"))


def print_data(sender, data):
    print(get_data("storedData"))


start_dearpygui()</code></pre>
    </article>

    <article><a name="menu_bar"></a>
        <h2>Menu Bar</h2>
        <hr>
        <p>
            A very important widget for GUI functionality is a Menu Bar. Menu bars are always displayed on the top of a window and have 3 main parts:
            <ol>
                <li>The Menu Bar - The main menu ribbon</li>
                <li>Menus - Drop down menus "sub-menus"</li>
                <li>Menu Items - Items that can run callbacks (basically selectables)</li>
                <li>Any Widget - Plot, drawing, ect</li>
            </ol>
            the Menu Bar and Menu are both container widgets and their container must be concluded with the respective "end" call.
            Items are added to the Menu Bar from right to left. Items are added to the menus from top to bottom.
            <br><br>
            Menus can be cascaded as much as necessary.
            <br><br>
            Any widget can be added to a menu.
        </p>
        <pre><code data-language="python">from dearpygui.dearpygui import *

add_menu_bar("Main Menu Bar")
add_menu("File")
add_menu_item("Save", callback="print_me")
add_menu_item("Save As", callback="print_me")
add_menu("Settings")
add_menu_item("Setting 1", callback="print_me")
add_menu_item("Setting 2", callback="print_me")
end_menu()
end_menu()
add_menu_item("Help", callback="print_me")
add_menu("Widget Items")
add_checkbox("Pick Me", callback="print_me")
add_button("Press Me", callback="print_me")
add_color_picker4("Color Me", callback="print_me")
end_menu()
end_menu_bar()


def print_me(sender, data):
    print("Menu Item: " + sender)


start_dearpygui()</code></pre>
    </article>
    <article><a name="plotting"></a>
        <h2>Plotting</h2>
        <hr>
        <p>
            DearPyGui has simple plots and plots both of which have the ability to be dynamic.
            <br><br>
            Simple plots take in a list and plot y-axis data against the number of items in the list. These can be
            line graphs or histograms and are demonstrated below.
        </p>
        <pre><code data-language="python">from dearpygui.dearpygui import *

add_simple_plot("Simpleplot1", [0.3, 0.9, 0.5, 0.3], height=300)
add_simple_plot("Simpleplot2", [0.3, 0.9, 2.5, 8.9], overlay="Overlaying", height=180, histogram=True)


start_dearpygui()</code></pre>
        <p> Plots have much more functionality that simple plots. Plots use both the x and y coordinates. Plots must be created using
            <code class="inline-code" data-language="python">add_plot()</code> command and then the data can bee added as either a
            line series or a scatter series.
            Features of plots are:
            <ul>
            <li>Click & Drag: to pan the plot</li>
            <li>Click & Drag on Axis: to pan the plot in one direction</li>
            <li>Double Click: scales plot to data</li>
            <li>Right Click & Drag: to zoom to an area</li>
            <li>Double Right Click: opens settings</li>
            <li>Shift + Right Click & Drag: to zoom to an area that fills a current axis</li>
            <li>Scroll Mouse Wheel: zooms</li>
            <li>Scroll Mouse Wheel on Axis: zooms only that axis</li>
            <li>Toggle data sets on the legend to hide them</li>
            </ul>
            <br><br>
            Additionally a text point can be used to place floating text on the plot.
        </p>
        <pre><code data-language="python">from dearpygui.dearpygui import *
from math import cos, sin

add_button("Plot data", callback="plot_callback")
add_plot("Plot", "x-axis", "y-axis", height=-1)


def plot_callback(sender, data):
    clear_plot("Plot")

    data1 = []
    for i in range(0, 100):
        data1.append([3.14 * i / 180, cos(3 * 3.14 * i / 180)])

    data2 = []
    for i in range(0, 100):
        data2.append([3.14 * i / 180, sin(2 * 3.14 * i / 180)])

    add_line_series("Plot", "Cos", data1, weight=2, fill=[255, 0, 0, 100])
    add_scatter_series("Plot", "Sin", data2)


start_dearpygui()</code></pre>
        <p>
            Simple plots can be made dynamic by changing the value of the plot call with
            <code class="inline-code" data-language="python">set_value()</code>. This is shown below.
        </p>
        <pre><code data-language="python">from dearpygui.dearpygui import *
from math import sin

add_simple_plot("Simpleplot1", [], autoscale=False, minscale=-1.0, maxscale=1.0, height=300)

add_data("data1", [])
add_data("frameCount", 0)

set_render_callback("onMainRender")


def onMainRender(sender, data):
    frameCount = get_data("frameCount")
    frameCount+=1
    add_data("frameCount", frameCount)
    data1 = get_data("data1")
    if len(data1) > 100:
        data1.pop(0)
    data1.append(sin(frameCount/30))
    add_data("data1", data1)
    set_value("Simpleplot1", data1)

start_dearpygui()</code></pre>
        <p>
            Plots are much easier to make dynamic than simple plots. Dynamic function can be applied as easy as clearing
            the plot and adding new data using a callback such as render or widget.
            <code class="inline-code" data-language="python">set_value()</code>. This is shown below.
        </p>
        <pre><code data-language="python">from dearpygui.dearpygui import *
from math import cos

add_plot("Plot", "x-axis", "y-axis", height=-1)

add_data("data1", [])
add_data("frameCount", 0)

set_render_callback("plot_callback")

def plot_callback(sender, data):
    frameCount = get_data("frameCount")
    frameCount+=1
    data1 = get_data("data1")
    if len(data1) > 250:
        frameCount = 0
        data1.clear()
    data1.append([3.14 * frameCount / 180, cos(3 * 3.14 * frameCount / 180)])
    clear_plot("Plot")
    add_line_series("Plot", "Cos", data1, weight=2, fill=[255, 0, 0, 100])
    add_data("frameCount", frameCount)
    add_data("data1", data1)


start_dearpygui()</code></pre>
    </article>
    <article><a name="drawing"></a>
        <h2>Drawing/Canvas</h2>
        <hr>
        <p>
            DearPyGui has a low level drawing API that is well suited for primitive drawing, custom widgets or even dynamic drawings.
            <br><br>
            The drawing is started by calling <code class="inline-code" data-language="python">add_drawing()</code> then items can be added
            by calling their respective draw commands.
            The origin for the canvas is in the bottom left.
        </p>
            <pre><code data-language="python">from dearpygui.dearpygui import *

add_drawing("Drawing_1", width=300, height=300)
draw_line("Drawing_1", [10, 10], [100, 100], [255, 0, 0, 255], 1)
draw_text("Drawing_1", [16, 16], "Origin", color=[250, 250, 250, 255], size=15)
draw_arrow("Drawing_1", [50, 70], [100, 65], [0, 200, 255], 1, 10)

start_dearpygui()</code></pre>
    <p>
        Drawings have a scale, origin, and size that can all be accessed and set.
        The scale is a multiplier of the items x and y values. The size is in pixels.
    </p>
        <pre><code data-language="python">from dearpygui.dearpygui import *

add_drawing("Drawing_1", width=300, height=300)
draw_line("Drawing_1", [10, 10], [100, 100], [255, 0, 0, 255], 1)
draw_text("Drawing_1", [16, 16], "Origin", color=[250, 250, 250, 255], size=15)
draw_arrow("Drawing_1", [50, 70], [100, 65], [0, 200, 255], 1, 10)
set_drawing_origin("Drawing_1", 150, 150)
set_drawing_scale("Drawing_1", 2, 2)
set_drawing_size("Drawing_1", 400, 500)

start_dearpygui()</code></pre>
        <p>
            Although drawings can be made dynamic by clearing and redrawing the entire thing a more efficient method is offered.
            <br><br>
            To make a drawing dynamic we should use the tag keyword to tag the items we would like to redraw. Then simply call a draw command
            using the same tag. This will delete only that one item and redraw it wit the new command.
        </p>
        <pre><code data-language="python">from dearpygui.dearpygui import *

show_metrics()
add_drawing("Drawing_1", width=600, height=600)
draw_circle("Drawing_1", [150, 150], radius=20, color=[255, 255, 255, 255], segments=4, tag="circle##dynamic")

add_data("counter", 0)
add_data("modifier", 2)

def onRender(sender, data):
    counter = get_data("counter")
    counter += 1
    modifier = get_data("modifier")
    if counter < 300:
        modifier += 1
    elif counter < 600:
        modifier -= 1
    else:
        counter = 0
        modifier = 2

    xpos = 15 + modifier*1.25
    ypos = 15 + modifier*1.25
    color1 = 255 - modifier*.8
    color3 = 255 - modifier*.3
    color2 = 255 - modifier*.8
    radius = 15 + modifier/2
    segments = round(35-modifier/10)
    draw_circle("Drawing_1", [xpos, ypos], radius, [color1, color3, color2, 255], segments, tag="circle##dynamic")
    add_data("counter", counter)
    add_data("modifier", modifier)

set_render_callback("onRender")


start_dearpygui()</code></pre>
    </article>
    <article><a name="tables"></a>
        <h2>Tables</h2>
        <hr>
        <p>
            DearPyGui has a low level table API that is well suited for static and dynamic tables.
            <br><br>
            The table widget is started by calling <code class="inline-code" data-language="python">add_table()</code>.
            <br><br>
            To edit the table widget we can use the methods <code class="inline-code" data-language="python">add_row()</code>
            <code class="inline-code" data-language="python">add_column()</code> which will append the row/column to the
            last slot in the table.
            <br><br>
            Alternatively, we can insert rows/columns using
            <code class="inline-code" data-language="python">insert_row()</code>
            <code class="inline-code" data-language="python">insert_column()</code>.
            Columns and Rows are inserted according to their index argument. If the specified index already exists the exiting columns/rows
            will be bumped and the new row/column will be inserted at the specified index.
            <br><br>
            Also an added or inserted row/column will by default fill unspecified cells with empty cells.
        </p>
        <pre><code data-language="python">from dearpygui.dearpygui import *

add_table("Table Example", ["Header 0", "Header 1"])
add_row("Table Example", ["row 0", "text"])
add_row("Table Example", ["row 2", "text"])
add_column("Table Example", "Header 3", ["data","data"])
insert_row("Table Example", 1, ["row 1", "inserted row", "inserted row"])
insert_column("Table Example", 2, "Header 2", ["inserted with column", "inserted column", "inserted column"])

start_dearpygui()
            </code></pre>
        <p>
            Additionally, headers and cells can be renamed and their values be changed.
        </p>
        <pre><code data-language="python">from dearpygui.dearpygui import *

add_spacing(count=5)
add_button("Modify Selected Table Values", callback="modifyTables")
add_spacing(count=5)
add_table("Table Example", ["Header 0", "Header 1"])
add_row("Table Example", ["awesome row", "text"])
add_row("Table Example", ["super unique", "unique text"])
add_column("Table Example", "Header 2", ["text from column", "text from column"])
add_row("Table Example", ["boring row"])


def modifyTables(sender, data):
    print("Table Called: ", sender)
    coordList = get_table_selections("Table Example")
    print("Selected Cells (coordinates): ", coordList)
    for coordinates in coordList:
        set_table_item("Table Example", coordinates[0], coordinates[1], "New Value")
    set_headers("Table Example", ["New Header 0", "New Header 1", "New Header 2"])

start_dearpygui()
            </code></pre>
        <p>
            Tables cells are selectable. This means that we can apply a callback to the table and retrieve which cell was selected through the sender
            and even get the text inside the cell.
        </p>
        <pre><code data-language="python">from dearpygui.dearpygui import *

add_table("Table Example", ["Header 0", "Header 1"], callback="tablePrinter")
add_row("Table Example", ["awesome row", "text"])
add_row("Table Example", ["super unique", "unique text"])
add_column("Table Example", "Header 3", ["text from column", "text from column"])
add_row("Table Example", ["boring row"])


def tablePrinter(sender, data):
    print("Table Called: ", sender)
    coordList = get_table_selections("Table Example")
    print("Selected Cells (coordinates): ", coordList)
    names = []
    for coordinates in coordList:
        names.append(get_table_item("Table Example", coordinates[0], coordinates[1]))
    print(names)


start_dearpygui()
            </code></pre>
    </article>
</main>
</body>